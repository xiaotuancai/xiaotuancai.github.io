--- 
layout: post
title: 小白学设计模式：简单工厂模式
tags: 
- 设计模式
status: publish
type: post
published: true
top: false
---

1、这个设计模式出现的背景或遇到的问题是啥？

2、这个模式背后的原理是啥，如何理解？

3、为什么用了这个模式后，软件灵活性提升了？

4、该模式的优缺点

还是围绕上面的四个问题来展开学习简单工厂模式。

1、背景或问题

我们家里会有各种各样的电器，电器的功能虽然不同，但他们都满足同样的电器接口：插座。

这个插座定义了电源的统一方式，我们给电器充电的时候，不需要知道是什么电器，不需要知道各个

电器的功能原理，我们只需要看到插座这个统一的接口即可，通过插座统一对不同的电器进行充电。

相反的，如果我们没有这个统一的接口，我们充电可能是怎么一种情况呢？很可能是下面这个样子：&nbsp;

对于冰箱：

1、new实例化一个冰箱

2、调用冰箱的上电接口开始上电

对于电视：

1、new实例化一个电视

2、调用电视的上电接口开始上电

......

大家可想而知，随着电器的越来越多，我们要管理的代码量也越来越多，而且我们需要了解每个电器的接口

细节，万一这些接口发生变化，我们还得全部重新修改，重新实现，这对我们软件工程师的日常工作无疑会

造成很大的浪费：为了创建电器对象，需要工程师熟悉所有的电器接口实现......

基于keep simple、keep stupid的想法，简单工厂就来了

2、简单工厂是如何解决这个问题的

既然我们的程序员哥哥觉得创造电器的过程按原有的方式很难搞，那我们就把创建电器这部分隔离起来，程序员

哥哥就安心专研客户的关键需求。那怎么隔离呢？我们就建了一个工厂，这个工厂就专门负责造电器，至于

电器如何实现的，程序员哥哥不需要了解细节了，只需要跟工厂打交道就行了，这就好像是原来造电器各有各的

接口，现在通过工厂流水线的方式完成了一次工业的统一一样，有什么需求，让工厂把这个对象制造出来就行

了。简单一句话：通过工厂这种通用方式，完成制造业的标准化。

3、软件灵活性为什么提升了

程序员哥哥不需要了解这个复杂的世界的所有对象，只需要了解工厂有什么能力制造什么对象就行了，从精力

的1对多，变为了1对1。

简单工厂的本质是：选择实现。

注意简单工厂的重点在选择，实现是已经做好了的。就算实现再简单，也要由具体的实现类来实现，而不是在简单工厂里面来实现。简单工厂的目的在于为客户端来选择相应的实现，从而使得客户端和实现之间解耦，这样一来，具体实现发生了变化，就不用变动客户端了，这个变化会被简单工厂吸收和屏蔽掉。

实现简单工厂的难点就在于“如何选择”实现，前面讲到了几种传递参数的方法，那都是静态的参数，还可以实现成为动态的参数。比如：在运行期间，由工厂去读取某个内存的值，或者是去读取数据库中的值，然后根据这个值来选择具体的实现等等。

4、缺点

可能增加使用者的复杂度：如果通过客户端的参数来选择具体的实现类，那么就必须让客户端能理解各个参数所代表的具体功能和含义，这会增加客户端使用的难度，也部分暴露了内部实现，这种情况可以选用可配置的方式来实现